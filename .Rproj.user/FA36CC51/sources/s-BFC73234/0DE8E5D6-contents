function (object, newdata = NULL, newparams = NULL, se.fit = FALSE, 
          re.form = NULL, allow.new.levels = FALSE, type = c("link", 
                                                             "response", "conditional", "zprob", 
                                                             "zlink", "disp"), zitype = NULL, na.action = na.pass, 
          fast = NULL, debug = FALSE, ...) 
{
  if (!is.null(zitype)) {
    warning("zitype is deprecated: please use type instead")
    type <- zitype
  }
  type <- match.arg(type)
  pop_pred <- (!is.null(re.form) && ((re.form == ~0) || identical(re.form, 
                                                                  NA)))
  if (!(is.null(re.form) || pop_pred)) {
    stop("re.form must equal NULL, NA, or ~0")
  }
  ziPredNm <- switch(type, response = "corrected", link = , 
                     conditional = "uncorrected", zlink = , zprob = "prob", 
                     disp = "disp", stop("unknown type ", type))
  ziPredCode <- .valid_zipredictcode[ziPredNm]
  oldPar <- object$fit$par
  if (!is.null(newparams)) 
    oldPar <- newparams
  new_stuff <- !is.null(newdata) || !is.null(newparams) || 
    pop_pred
  if (isTRUE(fast) && new_stuff) {
    stop("fast=TRUE is not compatible with newdata/newparams/population-level prediction")
  }
  if (is.null(fast)) 
    fast <- !new_stuff
  do_pred_val <- if (!se.fit) 
    0
  else if (!grepl("link", type)) 
    1
  else 2
  if (fast) {
    ee <- environment(object$obj$fn)
    lp <- ee$last.par.best
    dd <- ee$data
    orig_vals <- dd[c("whichPredict", "doPredict", 
                      "ziPredictCode")]
    dd$whichPredict <- as.numeric(seq(nobs(object)))
    if (se.fit) {
      dd$doPredict <- do_pred_val
    }
    dd$ziPredictCode <- ziPredCode
    assign("data", dd, ee)
    newObj <- object$obj
    on.exit(expr = {
      for (i in names(orig_vals)) {
        dd[[i]] <- orig_vals[[i]]
        assign("data", dd, environment(object$obj$fn))
      }
    }, add = TRUE)
  }
  else {
    mc <- mf <- object$call
    m <- match(c("subset", "weights", "offset", 
                 "na.action"), names(mf), 0L)
    mf <- mf[c(1L, m)]
    mf$drop.unused.levels <- TRUE
    mf[[1]] <- as.name("model.frame")
    tt <- terms(object$modelInfo$allForm$combForm)
    pv <- attr(terms(model.frame(object)), "predvars")
    attr(tt, "predvars") <- fix_predvars(pv, tt)
    mf$formula <- RHSForm(tt, as.form = TRUE)
    if (is.null(newdata)) {
      mf$data <- mc$data
      newFr <- object$frame
    }
    else {
      mf$data <- newdata
      mf$na.action <- na.action
      newFr <- eval.parent(mf)
    }
    omi <- object$modelInfo
    respCol <- match(respNm <- names(omi$respCol), names(newFr))
    newFr[[respNm]] <- NA
    safe_contrasts <- function(x) {
      if (length(levels(x)) < 2) 
        return(NULL)
      else return(contrasts(x))
    }
    aug_contrasts <- function(c1, new_levels) {
      rbind(c1, matrix(0, ncol = ncol(c1), nrow = length(new_levels), 
                       dimnames = list(new_levels, colnames(c1))))
    }
    augFr <- rbind(object$frame, newFr)
    facs <- which(vapply(augFr, is.factor, logical(1)))
    for (fnm in names(augFr)[facs]) {
      c1 <- safe_contrasts(object$frame[[fnm]])
      c2 <- safe_contrasts(newFr[[fnm]])
      if (!allow.new.levels) {
        c1_sub <- c1[rownames(c2), colnames(c2), drop = FALSE]
        if (!is.null(c2) && !(isTRUE(all.equal(c1_sub, 
                                               c2)) || isTRUE(all.equal(c1, c2)))) {
          stop("contrasts mismatch between original and prediction frame in variable ", 
               sQuote(fnm))
        }
      }
      if (!is.null(c1)) {
        new_levels <- stats::na.omit(setdiff(unique(newFr[[fnm]]), 
                                             levels(object$frame[[fnm]])))
        contrasts(augFr[[fnm]]) <- aug_contrasts(c1, 
                                                 new_levels)
      }
    }
    w <- nrow(object$fr) + seq_len(nrow(newFr))
    yobs <- augFr[[names(omi$respCol)]]
    TMBStruc <- eval.parent(mkTMBStruc(RHSForm(omi$allForm$formula, 
                                               as.form = TRUE), omi$allForm$ziformula, omi$allForm$dispformula, 
                                       omi$allForm$combForm, mf, fr = augFr, yobs = yobs, 
                                       respCol = respCol, weights = model.weights(augFr), 
                                       contrasts = omi$contrasts, family = omi$family, ziPredictCode = ziPredNm, 
                                       doPredict = do_pred_val, whichPredict = w, REML = omi$REML, 
                                       map = omi$map, sparseX = omi$sparseX))
    if (debug) 
      return(TMBStruc)
    assertIdenticalModels(TMBStruc$data.tmb, object$obj$env$data, 
                          allow.new.levels)
    if (se.fit) {
      with(TMBStruc$data.tmb, if (any(!is.finite(X)) | 
                                  any(!is.finite(Z@x)) | any(!is.finite(Xzi)) | 
                                  any(!is.finite(Zzi@x)) | any(!is.finite(Xd))) 
        stop("Some variables in newdata needed for predictions contain NAs or NaNs.\n           This is currently incompatible with se.fit=TRUE."))
    }
    if (!is.null(maparg <- TMBStruc$mapArg)) {
      full_pars <- get_pars(object, unlist = FALSE)
      for (i in names(maparg)) {
        mapind <- which(is.na(maparg[[i]]))
        if (length(mapind) > 0) {
          TMBStruc$parameters[[i]][mapind] <- full_pars[[i]][mapind]
        }
      }
    }
    if (pop_pred) {
      TMBStruc <- within(TMBStruc, {
        parameters$b[] <- 0
        mapArg$b <- factor(rep(NA, length(parameters$b)))
      })
    }
    n_orig <- openmp(n = object$modelInfo$parallel)
    on.exit(openmp(n_orig), add = TRUE)
    newObj <- with(TMBStruc, MakeADFun(data.tmb, parameters, 
                                       map = mapArg, random = randomArg, profile = NULL, 
                                       silent = TRUE, DLL = "glmmTMB"))
    newObj$fn(oldPar)
    lp <- newObj$env$last.par
  }
  na.act <- attr(model.frame(object), "na.action")
  do.napred <- missing(newdata) && !is.null(na.act)
  if (!is.null(parallel <- object$modelInfo$parallel)) {
    n_orig <- openmp(NULL)
    if (debug_openmp) 
      cat("resetting TMB threads to ", parallel, 
          "\n")
    openmp(parallel)
    on.exit(openmp(n = n_orig), add = TRUE)
  }
  if (debug_openmp) 
    cat("TMB threads currently set to ", openmp(NULL), 
        "\n")
  return_eta <- type %in% c("zlink", "link")
  if (!se.fit) {
    rr <- newObj$report(lp)
    pred <- if (return_eta) 
      rr$eta_predict
    else rr$mu_predict
  }
  else {
    H <- with(object, optimHess(oldPar, obj$fn, obj$gr))
    sdr <- sdreport(newObj, oldPar, hessian.fixed = H, getReportCovariance = FALSE)
    sdrsum <- summary(sdr, "report")
    w <- if (return_eta) 
      "eta_predict"
    else "mu_predict"
    w <- which(rownames(sdrsum) == w)
    pred <- sdrsum[w, "Estimate"]
    se <- sdrsum[w, "Std. Error"]
  }
  if (do.napred) {
    pred <- napredict(na.act, pred)
    if (se.fit) 
      se <- napredict(na.act, se)
  }
  if (!se.fit) 
    return(pred)
  else return(list(fit = pred, se.fit = se))
}



> getAnywhere("ranef.glmmTMB")
A single object matching ‘ranef.glmmTMB’ was found
It was found in the following places
registered S3 method for ranef from namespace glmmTMB
namespace:glmmTMB
with value

function (object, condVar = TRUE, ...) 
{
  check_dots(...)
  arrange <- function(x, sd, listname) {
    cnms <- object$modelInfo$reTrms[[listname]]$cnms
    reStruc <- object$modelInfo$reStruc[[paste0(listname, 
                                                "ReStruc")]]
    flist <- object$modelInfo$reTrms[[listname]]$flist
    levs <- lapply(flist, levels)
    if (!is.null(cnms)) {
      asgn <- attr(flist, "assign")
      nc <- vapply(reStruc, function(x) x$blockSize, numeric(1))
      nb <- vapply(reStruc, function(x) x$blockReps, numeric(1))
      nbseq <- rep.int(seq_along(nb), nb * nc)
      ml <- split(x, nbseq)
      for (i in seq_along(ml)) {
        ml[[i]] <- matrix(ml[[i]], ncol = nc[i], byrow = TRUE, 
                          dimnames = list(NULL, cnms[[i]]))
      }
      if (!is.null(sd)) {
        sd <- split(sd, nbseq)
        for (i in seq_along(sd)) {
          a <- array(NA, dim = c(nc[i], nc[i], nb[i]))
          for (j in seq(nb[i])) {
            a[cbind(seq(nc[i]), seq(nc[i]), j)] <- (sd[[i]][nc[i] * 
                                                              (j - 1) + seq(nc[i])])^2
          }
          sd[[i]] <- a
        }
      }
      x <- lapply(seq_along(flist), function(i) {
        m <- ml[asgn == i]
        b2 <- vapply(m, nrow, numeric(1))
        ub2 <- unique(b2)
        if (length(ub2) > 1) 
          stop("differing numbers of b per group")
        rnms <- if (ub2 == length(levs[[i]])) 
          levs[[i]]
        else seq(ub2)
        d <- data.frame(do.call(cbind, m), row.names = rnms, 
                        check.names = FALSE)
        if (!is.null(sd)) {
          attr(d, "condVar") <- if (length(w <- which(asgn == 
                                                      i)) > 1) {
            sd[w]
          }
          else sd[[w]]
        }
        return(d)
      })
      names(x) <- names(flist)
      return(x)
    }
    else {
      list()
    }
  }
  pl <- getParList(object)
  if (condVar && hasRandom(object)) {
    ss <- summary(object$sdr, "random")
    sdl <- list(b = ss[rownames(ss) == "b", "Std. Error"], 
                bzi = ss[rownames(ss) == "bzi", "Std. Error"])
  }
  else sdl <- NULL
  structure(list(cond = arrange(pl$b, sdl$b, "cond"), 
                 zi = arrange(pl$bzi, sdl$bzi, "zi")), class = "ranef.glmmTMB")
}
<bytecode: 0x000002368dd6dd88>
  <environment: namespace:glmmTMB>
